{"pageProps":{"proj_id":"masc","project":{"url":"https://github.com/pfgithub/masc","img":[324,174,"/icons/masc.png"],"title":"masc","body":["A programming language that compiles to human-readable mips assembly."],"technologies":["typescript","assembly"],"github":{"repo":"pfgithub/masc","branch":"master"}},"project_readme":{"text":"<h1><a id=\"user-content-mips-masc\" class=\"anchor\" aria-hidden=\"true\" href=\"https://github.com/pfgithub/masc/blob/master/#mips-masc\" target=\"_blank\" rel=\"noopener noreferrer\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>mips masc</h1><p>generate mips from human code</p><p>example:</p><div class=\"highlight highlight-source-zig\"><pre><span class=\"pl-s\">\\\\.text</span><span class=\"pl-s\">\\\\j main</span><span class=\"pl-k\">fn</span><span class=\"pl-en\">gcd</span>(<span class=\"pl-v\">a</span>: <span class=\"pl-k\">i32</span>, <span class=\"pl-v\">b</span>: <span class=\"pl-k\">i32</span>) <span class=\"pl-k\">i32</span> { <span class=\"pl-k\">if</span><span class=\"pl-v\">b</span><span class=\"pl-k\">==</span><span class=\"pl-c1\">0</span> {<span class=\"pl-k\">return</span><span class=\"pl-v\">a</span>;} <span class=\"pl-k\">return</span><span class=\"pl-v\">gcd</span>(<span class=\"pl-v\">b</span>, <span class=\"pl-v\">a</span><span class=\"pl-k\">%</span><span class=\"pl-v\">b</span>);\n} <span class=\"pl-s\">\\\\main:</span><span class=\"pl-k\">var</span><span class=\"pl-v\">gcd_value</span><span class=\"pl-k\">=</span><span class=\"pl-v\">gcd</span>(<span class=\"pl-c1\">25</span>, <span class=\"pl-c1\">15</span>);\n\n$<span class=\"pl-v\">v0</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">1</span>;\n$<span class=\"pl-v\">a0</span><span class=\"pl-k\">=</span><span class=\"pl-v\">gcd_value</span>; <span class=\"pl-s\">\\\\syscall</span><span class=\"pl-k\">!</span><span class=\"pl-v\">clear</span> $<span class=\"pl-v\">call</span>;</pre></div><p align=\"center\">↓</p><div class=\"highlight highlight-source-yaml\"><pre><span class=\"pl-s\">.text </span><span class=\"pl-c\"><span class=\"pl-c\">#</span> .text</span><span class=\"pl-s\">j main </span><span class=\"pl-c\"><span class=\"pl-c\">#</span> j main</span><span class=\"pl-c\"><span class=\"pl-c\">#</span> ====================</span><span class=\"pl-c\"><span class=\"pl-c\">#</span> jal call_gcd</span><span class=\"pl-c\"><span class=\"pl-c\">#</span> args:</span><span class=\"pl-c\"><span class=\"pl-c\">#</span> $a0: a - i32</span><span class=\"pl-c\"><span class=\"pl-c\">#</span> $a1: b - i32</span><span class=\"pl-c\"><span class=\"pl-c\">#</span> return:</span><span class=\"pl-c\"><span class=\"pl-c\">#</span> $v0: i32</span><span class=\"pl-c\"><span class=\"pl-c\">#</span> ====================</span><span class=\"pl-ent\">call_gcd</span>: <span class=\"pl-c\"><span class=\"pl-c\">#</span> fn gcd(a: i32, b: i32) i32{</span><span class=\"pl-c\"><span class=\"pl-c\">#</span> save used s registers to stack</span><span class=\"pl-s\">subiu $sp, $sp, 4 </span><span class=\"pl-c\"><span class=\"pl-c\">#</span> $sp = &amp;$sp[-1]</span><span class=\"pl-s\">sw $ra, 0($sp) </span><span class=\"pl-c\"><span class=\"pl-c\">#</span> $sp[0] = $ra</span><span class=\"pl-c\"><span class=\"pl-c\">#</span></span><span class=\"pl-s\">move $t0 $a0 </span><span class=\"pl-c\"><span class=\"pl-c\">#</span> a = $a0</span><span class=\"pl-s\">move $t1 $a1 </span><span class=\"pl-c\"><span class=\"pl-c\">#</span> b = $a1</span><span class=\"pl-c\"><span class=\"pl-c\">#</span> body</span><span class=\"pl-s\">bnez $t1, if_end </span><span class=\"pl-c\"><span class=\"pl-c\">#</span> if b == 0 {</span><span class=\"pl-s\">move $v0 $t0 </span><span class=\"pl-c\"><span class=\"pl-c\">#</span> .      a</span><span class=\"pl-s\">j deinit_gcd </span><span class=\"pl-c\"><span class=\"pl-c\">#</span> return ^;</span><span class=\"pl-ent\">if_end</span>: <span class=\"pl-c\"><span class=\"pl-c\">#</span> }</span><span class=\"pl-s\">move $a0 $t1 </span><span class=\"pl-c\"><span class=\"pl-c\">#</span> .               b</span><span class=\"pl-s\">rem $a1, $t0 $t1 </span><span class=\"pl-c\"><span class=\"pl-c\">#</span> |                  a % b</span><span class=\"pl-s\">jal call_gcd </span><span class=\"pl-c\"><span class=\"pl-c\">#</span> |           gcd(^, ^^^^^)</span><span class=\"pl-s\">move $v0, $v0 </span><span class=\"pl-c\"><span class=\"pl-c\">#</span> return$v0 = ^^^^^^^^^^^^^</span><span class=\"pl-c\"><span class=\"pl-c\">#</span></span><span class=\"pl-ent\">deinit_gcd</span>: <span class=\"pl-c\"><span class=\"pl-c\">#</span> cleanup:</span><span class=\"pl-c\"><span class=\"pl-c\">#</span> reload used s registers from stack</span><span class=\"pl-s\">lw $ra, 0($sp) </span><span class=\"pl-c\"><span class=\"pl-c\">#</span> $ra = $sp[0]</span><span class=\"pl-s\">addiu $sp, $sp, 4 </span><span class=\"pl-c\"><span class=\"pl-c\">#</span> $sp = &amp;$sp[1]</span><span class=\"pl-s\">jr $ra </span><span class=\"pl-c\"><span class=\"pl-c\">#</span> }</span><span class=\"pl-ent\">main</span>: <span class=\"pl-c\"><span class=\"pl-c\">#</span> main:</span><span class=\"pl-s\">li $a0 25 </span><span class=\"pl-c\"><span class=\"pl-c\">#</span> .                   25</span><span class=\"pl-s\">li $a1 15 </span><span class=\"pl-c\"><span class=\"pl-c\">#</span> |                       15</span><span class=\"pl-s\">jal call_gcd </span><span class=\"pl-c\"><span class=\"pl-c\">#</span> |               gcd(^^, ^^)</span><span class=\"pl-s\">move $t0, $v0 </span><span class=\"pl-c\"><span class=\"pl-c\">#</span> var gcd_value = ^^^^^^^^^^^</span><span class=\"pl-s\">li $v0 1 </span><span class=\"pl-c\"><span class=\"pl-c\">#</span> $v0 = 1</span><span class=\"pl-s\">move $a0 $t0 </span><span class=\"pl-c\"><span class=\"pl-c\">#</span> $a0 = gcd_value</span><span class=\"pl-s\">syscall </span><span class=\"pl-c\"><span class=\"pl-c\">#</span> syscall</span></pre></div><h2><a id=\"user-content-syntax\" class=\"anchor\" aria-hidden=\"true\" href=\"https://github.com/pfgithub/masc/blob/master/#syntax\" target=\"_blank\" rel=\"noopener noreferrer\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>syntax</h2><p>inspired by zig.</p><p><a href=\"https://github.com/pfgithub/masc/tree/master/src/tests\" target=\"_blank\" rel=\"noopener noreferrer\">examples</a>.</p><p>statement:</p><ul><li><code>var varname: TYPE = EXPRESSION;</code> - define variable</li><li><code>variable | register = EXPRESSION;</code> - set variable. eg <code>myvar = 3;</code> or <code>$v0 = 5;</code></li><li><code>save EXPRESSION = EXPRESSION</code> - save into memory. eg <code>save myptr.* = 25;</code>. you may wonder why this is not just <code>myptr.* = 25;</code> and the answer to that is there is no\ngood reason and that way would be better but isn't supported because only variable | register is supported and I wasn't thinking enough when implementing this.</li><li><code>inline? fn function_name(arg_name: TYPE, ...) { STATEMENT... }</code> - define ¿inline? function. make sure to jump over functions.\nfunctions will save any needed things to the stack (and unneeded because they will always save $ra even if they don't call any functions oops)</li><li><code>loop { STATEMENT ... }</code> - loop forever. break/continue out of the loop.</li><li><code>if EXPRESSION operator EXPRESSION { STATEMENT... }</code> - expression: <code>&lt;=</code>, <code>&lt;</code>, <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&gt;=</code>.</li><li><code>!clear $ra, $call, ...</code> - tell the register allocator that these variables cannot be used. <code>$call</code> expands into $t0-7, $a0-4, $ra, $v0-1. this way, using a variable across a syscall makes it go into $s0-7.</li><li><code>\\\\inline assembly...</code> - inline assembly currently has no option to use variables. make sure to !clear any used registers after inline assembly. eg: <code>\\syscall</code></li><li><code>return EXPRESSION?;</code> - return a value from a function</li><li><code>break;</code> - break from a loop</li><li><code>continue;</code> - continue in a loop</li></ul><p>types:</p><ul><li><code>u32</code>, <code>i32</code>, <code>u8</code> - unsigned and signed integer types</li><li><code>[*]TYPE</code> - pointer to array (indexable, math supported)</li><li><code>*TYPE</code> - pointer to one (not indexable, no math)</li><li><code>void</code> - nothing. for use as a return value</li><li><code>any</code> - any value (up to 32 bits)</li></ul><p>expression:</p><ul><li><code>variable_name</code></li><li><code>@TYPE:data_name</code> - get something from the .data section with name data_name and type TYPE. example: <code>@i32:len</code> or <code>@[*]i32:x[25]</code>. masc doesn't help with defining items in the .data section, do it yourself.</li><li><code>$register_name</code> - use a register</li><li><code>function_name(EXPRESSION, ...)</code> - call a function</li><li><code>EXPRESSION + - * / ^ % EXPRESSION</code> - math. eg <code>1 + 1</code> or <code>5 * 3 + 6 % 8</code>. <code>^</code> is binary xor.</li><li><code>EXPRESSION[EXPRESSION]</code> - index array, eg <code>somearray[5]</code></li><li><code>EXPRESSION.*</code> - get value of pointer, eg <code>somepointer.*</code></li><li><code>&amp;EXPRESSION</code> - address of expression, eg <code>&amp;somepointer[2]</code></li><li><code>undefined</code> - anything. eg <code>var varname: u32 = undefined;</code></li><li><code>25</code> - any number, eg <code>-8</code> or <code>5325</code>. no binary literals, hex literals, or floating point numbers supported.</li></ul><p>comments:</p><ul><li><code>// asdfnjdksalk</code> - comment that will not be visible in the output code</li><li><code>/* asdfnjdks */</code> - comment that will not be visible in the output code</li><li><code>\\\\# comment that will be visible in the output code</code> (inline assembly \"#\")</li><li><code>\\\\</code> - newline that will be visible in the output code</li></ul><p>there's probably more that I'm missing. look at the examples.</p><h2><a id=\"user-content-notes\" class=\"anchor\" aria-hidden=\"true\" href=\"https://github.com/pfgithub/masc/blob/master/#notes\" target=\"_blank\" rel=\"noopener noreferrer\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>notes</h2><p>all variables are stored in a register. if you run out of registers, save some\nthings to the stack manually yourself.</p><h2><a id=\"user-content-source-code-structure\" class=\"anchor\" aria-hidden=\"true\" href=\"https://github.com/pfgithub/masc/blob/master/#source-code-structure\" target=\"_blank\" rel=\"noopener noreferrer\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>source code structure</h2><p>don't look at the source code it's very bad because it constantly does string manipulation instead of being resonable and storing useful data.</p><h2><a id=\"user-content-issues\" class=\"anchor\" aria-hidden=\"true\" href=\"https://github.com/pfgithub/masc/blob/master/#issues\" target=\"_blank\" rel=\"noopener noreferrer\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>issues</h2><ul><li>no parenthesis expression. you can't do <code>(1 + 1) * 2</code></li><li>newlines have to be explicitly preserved</li><li>inline function call comments are all on one line</li><li>no strings, no way to make a print function</li><li>no way to make a macro fn</li><li>lots of missing integer types</li><li>supporting larger types (eg doubles) would require a pretty big refactor probably</li><li>too many registers has no position associated with the error</li><li>register allocation bugs probably</li><li>the source code</li></ul><p>lots. glhf if you want to actually use this.</p>"}},"__N_SSG":true}